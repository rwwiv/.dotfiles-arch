#!/usr/bin/env python3
"""Waybar VPN indicator for Tailscale and WireGuard."""

from __future__ import annotations

import json
import subprocess
import sys
import threading
import time
from typing import Any

# --- Configuration ---
WG_INTERFACE = "wg0"

# --- Output States ---
TS_STATES: dict[str, dict[str, str]] = {
    "Running": {"text": "ts 󰒙", "class": "vpn-ts-on", "tooltip": "Tailscale: Connected"},
    "Starting": {"text": "ts ...", "class": "vpn-ts-wait", "tooltip": "Tailscale: Connecting..."},
    "NeedsLogin": {"text": "ts 󰦜", "class": "vpn-ts-auth", "tooltip": "Tailscale: Needs Login"},
    "Stopped": {"text": "ts 󰦜", "class": "vpn-ts-off", "tooltip": "Tailscale: Stopped"},
    "NoState": {"text": "ts 󰦜", "class": "vpn-ts-off", "tooltip": "Tailscale: Not Ready"},
}

WG_STATES: dict[str, dict[str, str]] = {
    "UP": {"text": "wg 󰒙", "class": "vpn-wg-on", "tooltip": "WireGuard: Connected"},
    "DOWN": {"text": "wg 󰦜", "class": "vpn-wg-off", "tooltip": "WireGuard: Disconnected"},
}

STATE_DISCONNECTED: dict[str, str] = {
    "text": "vpn 󰦜",
    "class": "vpn-off",
    "tooltip": "No VPN Connected",
}

# Tailscale state numeric to string mapping
TS_STATE_MAP: dict[int, str] = {
    2: "NeedsLogin",
    4: "Stopped",
    5: "Starting",
    6: "Running",
}

# --- Global State ---
current_state: dict[str, str] = {
    "ts": "Stopped",
    "wg": "DOWN",
}
state_lock = threading.Lock()


def print_status() -> None:
    """Output current VPN status as JSON for Waybar."""
    with state_lock:
        ts = current_state["ts"]
        wg = current_state["wg"]

    # Priority: Tailscale > WireGuard
    if ts == "Running":
        output = TS_STATES[ts].copy()
    elif wg == "UP":
        output = WG_STATES[wg].copy()
    elif ts in ("Starting", "NeedsLogin"):
        output = TS_STATES[ts].copy()
    else:
        output = STATE_DISCONNECTED.copy()

    # Format status strings
    ts_fmt = "Running" if ts == "Running" else ts
    wg_fmt = "Running" if wg == "UP" else "Stopped"

    # Enrich tooltip with full details
    output["tooltip"] = f"Tailscale: {ts_fmt}\nWireGuard: {wg_fmt}"

    print(json.dumps(output), flush=True)


def watch_tailscale() -> None:
    """Watch tailscale debug watch-ipn for state changes."""
    # Initial check
    try:
        proc = subprocess.run(
            ["tailscale", "status", "--json"],
            capture_output=True,
            text=True,
            check=False,
        )
        if proc.returncode == 0:
            data = json.loads(proc.stdout)
            with state_lock:
                current_state["ts"] = data.get("BackendState", "NoState")
    except Exception:
        pass

    print_status()

    # Watch loop
    cmd = ["tailscale", "debug", "watch-ipn"]
    process = subprocess.Popen(
        cmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True
    )

    # Parse the stream through jq for proper JSON handling
    jq = subprocess.Popen(
        ["jq", "--unbuffered", "-c", "."],
        stdin=process.stdout,
        stdout=subprocess.PIPE,
        text=True,
        bufsize=1,
    )
    if process.stdout:
        process.stdout.close()  # Allow SIGPIPE

    try:
        if jq.stdout:
            for line in iter(jq.stdout.readline, ""):
                if not line:
                    break
                try:
                    data: dict[str, Any] = json.loads(line)
                    new_state = data.get("State")

                    if isinstance(new_state, int):
                        str_state = TS_STATE_MAP.get(new_state, str(new_state))
                    else:
                        str_state = str(new_state) if new_state else None

                    if str_state is not None:
                        with state_lock:
                            current_state["ts"] = str_state
                        print_status()
                except (ValueError, json.JSONDecodeError):
                    pass
    except Exception:
        pass
    finally:
        jq.kill()
        process.kill()


def check_wireguard() -> str:
    """Check WireGuard interface status."""
    try:
        cmd = ["ip", "-j", "link", "show", WG_INTERFACE]
        res = subprocess.run(cmd, capture_output=True, text=True, check=False)
        if res.returncode != 0:
            return "DOWN"
        data = json.loads(res.stdout)
        if not data:
            return "DOWN"
        flags = data[0].get("flags", [])
        return "UP" if "UP" in flags else "DOWN"
    except Exception:
        return "DOWN"


def watch_wireguard() -> None:
    """Watch ip monitor link for WireGuard interface changes."""
    # Initial check
    with state_lock:
        current_state["wg"] = check_wireguard()
    print_status()

    # Monitor for changes
    cmd = ["ip", "monitor", "link"]
    process = subprocess.Popen(
        cmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True
    )

    try:
        if process.stdout:
            for line in iter(process.stdout.readline, ""):
                if WG_INTERFACE in line:
                    # Small sleep to let state settle
                    time.sleep(0.2)
                    new_status = check_wireguard()
                    changed = False
                    with state_lock:
                        if current_state["wg"] != new_status:
                            current_state["wg"] = new_status
                            changed = True
                    if changed:
                        print_status()
    except Exception:
        pass
    finally:
        process.kill()


def main() -> int:
    """Main entry point."""
    t1 = threading.Thread(target=watch_tailscale, daemon=True)
    t2 = threading.Thread(target=watch_wireguard, daemon=True)

    t1.start()
    t2.start()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        return 0

    return 0


if __name__ == "__main__":
    sys.exit(main())
