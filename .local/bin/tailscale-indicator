#!/usr/bin/env python3
import sys
import json
import subprocess

# Tailscale State Enum (ipn/backend.go)
# 0: NoState, 1: InUseOtherUser, 2: NeedsLogin, 3: NeedsMachineAuth, 
# 4: Stopped, 5: Starting, 6: Running
STATES = {
    6: {"text": "up 󰒙", "class": "vpn-on", "tooltip": "Tailscale Connected"},
    4: {"text": "down 󰦜", "class": "vpn-off", "tooltip": "Tailscale Stopped"},
    2: {"text": "auth 󰦜", "class": "vpn-auth", "tooltip": "Tailscale Needs Login"},
    5: {"text": "... 󰦜", "class": "vpn-waiting", "tooltip": "Tailscale Starting..."}
}
DEFAULT = {"text": "err 󰦜", "class": "vpn-off", "tooltip": "Tailscale Error"}

def print_status(state_key):
    data = STATES.get(state_key, DEFAULT)
    # Fallback for unknown states (like 1 or 3)
    if state_key not in STATES:
        data["tooltip"] = f"Status: {state_key}"
    print(json.dumps(data), flush=True)

def main():
    # 1. Initial State (Fast) via status --json (uses string state)
    try:
        proc = subprocess.run(["tailscale", "status", "--json"], capture_output=True, text=True)
        if proc.returncode == 0:
            st = json.loads(proc.stdout)
            bs = st.get("BackendState", "")
            # Map string to int for consistency
            if bs == "Running": print_status(6)
            elif bs == "Stopped": print_status(4)
            elif bs == "NeedsLogin": print_status(2)
            else: print_status(0)
    except Exception:
        print_status(0)

    # 2. Watcher
    # We pipe tailscale -> jq -c . to flatten the pretty-printed JSON into single lines
    # This allows us to simply use readline() in python.
    ts_proc = subprocess.Popen(
        ["tailscale", "debug", "watch-ipn"],
        stdout=subprocess.PIPE,
        stderr=subprocess.DEVNULL
    )
    
    jq_proc = subprocess.Popen(
        ["jq", "--unbuffered", "-c", "."],
        stdin=ts_proc.stdout,
        stdout=subprocess.PIPE,
        text=True,
        bufsize=1
    )

    # Allow ts_proc to receive SIGPIPE if jq exits
    ts_proc.stdout.close()

    try:
        for line in iter(jq_proc.stdout.readline, ''):
            if not line: break
            try:
                data = json.loads(line)
                # 'State' is often null in partial updates, ignore those
                state = data.get("State")
                if state is not None:
                    print_status(state)
            except json.JSONDecodeError:
                pass
    except KeyboardInterrupt:
        pass
    finally:
        jq_proc.kill()
        ts_proc.kill()

if __name__ == "__main__":
    main()
