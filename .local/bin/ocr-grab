#!/bin/bash

# Dependency Check
if ! command -v tesseract &> /dev/null; then
    notify-send "OCR Error" "Tesseract not found. Install 'tesseract' and 'tesseract-data-eng'" -u critical
    exit 1
fi

# Allow cancelling by running again
pkill slurp && exit 0

MODE="${1:-smart}"

get_rectangles() {
  local active_workspace=$(hyprctl monitors -j | jq -r '.[] | select(.focused == true) | .activeWorkspace.id')
  hyprctl monitors -j | jq -r --arg ws "$active_workspace" '.[] | select(.activeWorkspace.id == ($ws | tonumber)) | "\(.x),\(.y) \((.width / .scale) | floor)x\((.height / .scale) | floor)"'
  hyprctl clients -j | jq -r --arg ws "$active_workspace" '.[] | select(.workspace.id == ($ws | tonumber)) | "\(.at[0]),\(.at[1]) \(.size[0])x\(.size[1])"'
}

# Select based on mode
case "$MODE" in
  region)
    wayfreeze & PID=$!
    sleep .1
    SELECTION=$(slurp 2>/dev/null)
    kill $PID 2>/dev/null
    ;;
  windows)
    wayfreeze & PID=$!
    sleep .1
    SELECTION=$(get_rectangles | slurp -r 2>/dev/null)
    kill $PID 2>/dev/null
    ;;
  fullscreen)
    SELECTION=$(hyprctl monitors -j | jq -r '.[] | select(.focused == true) | "\(.x),\(.y) \((.width / .scale) | floor)x\((.height / .scale) | floor)"')
    ;;
  smart|*)
    RECTS=$(get_rectangles)
    wayfreeze & PID=$!
    sleep .1
    SELECTION=$(echo "$RECTS" | slurp 2>/dev/null)
    kill $PID 2>/dev/null

    # "Smart Click" Logic from Omarchy
    # If selection < 20px area, treat it as a click and find the window/monitor under cursor
    if [[ "$SELECTION" =~ ^([0-9]+),([0-9]+)[[:space:]]([0-9]+)x([0-9]+)$ ]]; then
      if (( ${BASH_REMATCH[3]} * ${BASH_REMATCH[4]} < 20 )); then
        click_x="${BASH_REMATCH[1]}"
        click_y="${BASH_REMATCH[2]}"

        while IFS= read -r rect; do
          if [[ "$rect" =~ ^([0-9]+),([0-9]+)[[:space:]]([0-9]+)x([0-9]+) ]]; then
            rect_x="${BASH_REMATCH[1]}"
            rect_y="${BASH_REMATCH[2]}"
            rect_width="${BASH_REMATCH[3]}"
            rect_height="${BASH_REMATCH[4]}"

            if (( click_x >= rect_x && click_x < rect_x+rect_width && click_y >= rect_y && click_y < rect_y+rect_height )); then
              SELECTION="${rect_x},${rect_y} ${rect_width}x${rect_height}"
              break
            fi
          fi
        done <<< "$RECTS"
      fi
    fi
    ;;
esac

[ -z "$SELECTION" ] && exit 0

# ---------------------------------------------------------
# OCR PROCESSING
# ---------------------------------------------------------

notify-send "OCR" "Processing..." -t 1000 -i scanner

# 1. Capture selection with grim
# 2. Pipe to tesseract (specify English, use stdin/stdout)
# 3. Capture output to variable
TEXT=$(grim -g "$SELECTION" - | tesseract -l eng stdin stdout 2>/dev/null)

# Clean up whitespace (optional, but helpful)
TEXT_CLEAN=$(echo "$TEXT" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

if [ -n "$TEXT_CLEAN" ]; then
    echo "$TEXT_CLEAN" | wl-copy
    notify-send "OCR Success" "Copied to clipboard" -i edit-paste
else
    notify-send "OCR Failed" "No text detected" -u low -i dialog-warning
fi
